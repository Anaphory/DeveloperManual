<h1 id="some-guidance-for-developing-new-methods-in-beast-2"><span class="header-section-number">1</span> Some guidance for developing new methods in BEAST 2</h1>
<p>Disclaimer: below some ramblings on methods development for BEAST 2 <span class="citation">(Bouckaert <em>et al.</em> 2014, <span class="citation">Drummond and Bouckaert (2015)</span>, <span class="citation">Bouckaert <em>et al.</em> (2019)</span>)</span> packages. This is a living document. Use at own risk.</p>
<h2 id="testing-new-methods"><span class="header-section-number">1.1</span> Testing new methods</h2>
<p>New methods require usually require two parts: an implementation <span class="math inline"><em>I</em>(<em>M</em>)</span> of a model <span class="math inline"><em>M</em></span> and associated probability <span class="math inline"><em>p</em><sub><em>I</em></sub>(<em>θ</em>|<em>M</em>)</span> of states <span class="math inline"><em>θ</em></span>, and MCMC operators <span class="math inline"><em>R</em>(<em>θ</em>)→<em>θ</em>′</span> for creating proposals <span class="math inline"><em>θ</em>′</span> for moving through state space starting in state <span class="math inline"><em>θ</em></span> (though sometimes just an operator is validated that is much more efficient than previously existing operators). This guide contains some procedures to make sure that the model and operators are correctly implemented. Ideally, we have an independent implementation of a simulator <span class="math inline"><em>S</em>(<em>M</em>)→<em>θ</em></span> that allows (possibly inefficiently) to sample from the target distribution <span class="math inline"><em>p</em><sub><em>S</em></sub>(<em>θ</em>|<em>M</em>)</span>. If so, we also need to verify that the simulator is correctly implemented. In summary, we need to establish correctness of:</p>
<ul>
<li>the simulator implementation <span class="math inline"><em>S</em>(<em>M</em>)→<em>θ</em></span> (if any)</li>
<li>the model implementation <span class="math inline"><em>I</em>(<em>M</em>)</span></li>
<li>operator implementations <span class="math inline"><em>R</em></span></li>
</ul>
<h3 id="verify-correctness-of-simulator-implementation"><span class="header-section-number">1.1.1</span> Verify correctness of simulator implementation</h3>
<p>To verify correctness of a simulator implementation <span class="math inline"><em>S</em></span> for model <span class="math inline"><em>M</em></span> directly, the distributions <span class="math inline"><em>p</em><sub><em>S</em></sub>(<em>θ</em>|<em>M</em>)</span> should match expected distribution based on theory. We can verify this by drawing a large number of samples using <span class="math inline"><em>S</em></span>, calculate summary statistics on the sample and compare these with analytical estimates for these statistics. For example, ...</p>
<p>When no analytical estimates of statistics are available, ...</p>
<p>Examples of simulators:</p>
<ul>
<li>the <a href="http://tgvaughan.github.io/MASTER/">MASTER</a> <span class="citation">(Vaughan and Drummond 2013)</span> BEAST 2 package is a general purpose package for simulating stochastic population dynamics models which can be expressed in terms of a chemical master equation.</li>
<li>SimSnap for SNAPP <span class="citation">(Bryant <em>et al.</em> 2012)</span> is a custom build implementation in C++ for simulating alignments for a fixed tree and SNAPP parameters.</li>
<li>The <code>beast.app.seqgen.SequenceSimulator</code> can be used to simulate alignments for general site models using reversible substitution models. See <a href="https://github.com/CompEvol/beast2/blob/master/examples/testSeqGen.xml">testSeqGen.xml</a> for an example.</li>
<li>The <code>beast.core.DirectSimulator</code> class in BEAST 2 can be used to draw samples from distributions in BEAST that extend <code>beast.core.distribution.Distribution</code> and implement the <code>sample(state, random)</code> method. You can set up an XML file and run it in BEAST. Here are a few examples: <a href="https://github.com/CompEvol/beast2/blob/master/examples/testDirectSimulator.xml">testDirectSimulator.xml</a>, <a href="https://github.com/CompEvol/beast2/blob/master/examples/testDirectSimulator2.xml">testDirectSimulator2.xml</a>, and <a href="https://github.com/CompEvol/beast2/blob/master/examples/testDirectSimulatorHierarchical.xml">testDirectSimulatorHierarchical.xml</a>.</li>
</ul>
<h3 id="verify-correctness-of-model-implementation"><span class="header-section-number">1.1.2</span> Verify correctness of model implementation</h3>
<p>In theory, the inferred distributions <span class="math inline"><em>p</em><sub><em>I</em></sub>(<em>θ</em>|<em>M</em>)</span> should match the simulator distribution <span class="math inline"><em>p</em><sub><em>S</em></sub>(<em>θ</em>|<em>M</em>)</span>. However, drawing samples from <span class="math inline"><em>p</em><sub><em>I</em></sub>(<em>θ</em>|<em>M</em>)</span> typically requires running an MCMC chain, which requires MCMC proposals <span class="math inline"><em>R</em></span> to randomly walk through state space. If we do this, we need to rely on <span class="math inline"><em>R</em></span> being correctly implemented. So, if we find that <span class="math inline"><em>p</em><sub><em>I</em></sub>(<em>θ</em>|<em>M</em>)</span> and <span class="math inline"><em>p</em><sub><em>S</em></sub>(<em>θ</em>|<em>M</em>)</span> so not match, it is not possible to tell whether problem is with an operator <span class="math inline"><em>R</em></span> or with the model implementation <span class="math inline"><em>I</em>(<em>M</em>)</span>.</p>
<p>(Christiaan's technique to the rescue)</p>
<p>Comparing two distributions can be done by</p>
<ul>
<li>eye balling the marginal likelihoods in Tracer and making sure they are close enough.</li>
<li>testing whether parameters are covered 95% of the time in the 95% HPD interval of parameter distributions.</li>
<li>using a statistical test, e.g. the Kolmogorov-Smirnov test, to verify the distributions <span class="math inline"><em>p</em><sub><em>I</em></sub>(<em>θ</em>|<em>M</em>)</span> and <span class="math inline"><em>p</em><sub><em>S</em></sub>(<em>θ</em>|<em>M</em>)</span> are the same.</li>
</ul>
<p><code>TraceKSStats</code> calculate Kolmogorov-Smirnof statistic for comparing trace logs. TraceKSStats has the following inputs:</p>
<ul>
<li>trace1 (LogFile): first trace file to compare (required)</li>
<li>trace2 (LogFile): second trace file to compare (required)</li>
<li>burnin (Integer): percentage of trace logs to used as burn-in (and will be ignored) (optional, default: 10)</li>
</ul>
<p>Sample output:</p>
<pre><code>Trace entry                                      p-value
posterior                                        1.0
likelihood                                       0.21107622404022763
prior                                            0.036794035181748064
treeLikelihood                                   0.04781117967724258
TreeHeight                                       0.036794035181748064
YuleModel                                        0.005399806065857771
birthRate                                        0.2815361702146215
kappa                                            0.62072545444263
freqParameter.1                                  0.0
freqParameter.2                                  8.930072172019798E-5
freqParameter.3                                  1.0883734952171764E-6
freqParameter.4                                  0.0</code></pre>
<p>Though some values have very low p-values, meaning they differ significantly, it is recommended to verify this using Tracer to make sure that the test is not unduly influenced by outliers.</p>
<h3 id="verify-correctness-of-operator-implementations"><span class="header-section-number">1.1.3</span> Verify correctness of operator implementations</h3>
<p>Once simulator <span class="math inline"><em>S</em>(<em>M</em>)</span> and model implementation <span class="math inline"><em>I</em>(<em>M</em>)</span> are verified to be correct, next step is implementing efficient operators, running MCMCs to verify that parameters drawn from the prior are covered 95% of the time in the 95% HPD interval of parameter distributions.</p>
<p>The BEAST 2 <a href="https://github.com/rbouckaert/Experimenter">Experimenter</a> package can assist (see section &quot;Using the Experimenter package&quot; below).</p>
<h1 id="practical-considerations"><span class="header-section-number">2</span> Practical considerations</h1>
<p>Validation only covers cases in as far as the prior covers it -- most studies will not cover all possible cases, since the state space is just to large. Usually, informative priors are required for validation to work, since broader priors (e.g. some of the default tree priors in BEAST) lead to identifiability issues, for example, due to saturation of mutations along branches of a tree.</p>
<h1 id="setting-priors"><span class="header-section-number">3</span> Setting priors</h1>
<h2 id="trees-clock-model-parameters"><span class="header-section-number">3.1</span> Trees &amp; clock model parameters</h2>
<p>The mutation rate <span class="math inline"><em>μ</em></span> must have been such that the tree height <span class="math inline"><em>h</em><sub><em>T</em></sub></span> cannot exceed <span class="math inline">1/<em>μ</em></span> (in other words, <span class="math inline"><em>μ</em><em>h</em><sub><em>T</em></sub> ≤ 1</span>), otherwise there would be saturation, and sequences could not possibly have sufficient information to align. At the other end of the spectrum, where <span class="math inline"><em>μ</em><em>h</em><sub><em>T</em></sub></span> close to zero, very long sequences are required to ensure there are enough mutations in order to be able to reconstruct the tree distribution.</p>
<p>TODO: forumlate in terms of <span class="math inline"><em>N</em><sub><em>e</em></sub></span> instead of <span class="math inline"><em>h</em><sub><em>T</em></sub></span>?</p>
<ul>
<li>for reasonable computation times, trees should be about 0.5 substitutions high, OR</li>
<li>sequences should be very long to reliably reconstruct smaller trees.</li>
</ul>
<p>One way to enforce this is by</p>
<ul>
<li>a narrow prior on birth rates (for birth/death type tree priors), or</li>
<li>putting an MRCA prior on the height of the tree, for coalescent models. Note that the latter hampers direct simulator implementations.</li>
</ul>
<p>For clock models with mean clock rate != 1, simulate trees with clock rates times tree height approximately 0.5.</p>
<p>Published mutation rates can range from <span class="math inline"><em>O</em>(1<em>e</em> − 2)</span> substitutions per site per year for viruses such as HIV <span class="citation">(Cuevas <em>et al.</em> 2015)</span>, to <span class="math inline"><em>O</em>(1<em>e</em> − 11)</span> for conserved regions of nuclear DNA (e.g PyrE2 locus in Haloferax volcanii <span class="citation">(Lynch 2010)</span>).</p>
<p>For releases, tree priors for clock and trees should be made less informative in order to cater for a wider range of tree heights and clock rates.</p>
<h2 id="gamma-rate-heterogeneity"><span class="header-section-number">3.2</span> Gamma rate heterogeneity</h2>
<p>To prevent saturation, adding categories with slow rates will go some way to allow covering a larger range of clock rates. Using gamma rate heterogeneity with shape values in the range 0.1 to 1 allows this, so adopt a gamma shape prior accordingly.</p>
<h2 id="proportion-invariable-sites"><span class="header-section-number">3.3</span> Proportion invariable sites</h2>
<p>Since each site evolves with non-zero rate, use of proportion invariable sites is modeling the process badly, and therefore not recommended.</p>
<h2 id="frequencies"><span class="header-section-number">3.4</span> Frequencies</h2>
<p>Priors ideally should be set in realistic ranges, e.g. frequency priors not uniform(0,1) but Dirichlet(4,4,4,4) is better.</p>
<h2 id="substitution-model-parameters"><span class="header-section-number">3.5</span> Substitution model parameters</h2>
<p>Default priors seem OK for most substitution models.</p>
<h2 id="sequence-simulator"><span class="header-section-number">3.6</span> Sequence simulator</h2>
<p><code>SequenceSimulator</code> can help generate individual alignments.</p>
<p>To generate N XML files, use <code>CoverageTestXMLGenerator</code> in Experimenter package</p>
<p>The sequence length should be long enough that trees can be reasonably reliably recovered -- if the difference between longest and shorted tree is 2 orders of magnitude, nucleotide sequences of 10 thousand sites. When <span class="math inline"><em>μ</em></span>*treeh-height approximate 0.5, sequences of length 1000 are sufficient.</p>
<h2 id="log-file-names"><span class="header-section-number">3.7</span> Log file names</h2>
<p>Make sure log files names do not overlap. Use <code>logFileName=&quot;out$(N).log</code> and start BEAST with <code>for i in {0..99} do /path/to/beast/bin/beast -D N=$i beast$i.xml; done</code></p>
<h1 id="trouble-shooting"><span class="header-section-number">4</span> Trouble shooting</h1>
<h2 id="coverage-gone-wrong"><span class="header-section-number">4.1</span> Coverage gone wrong</h2>
<p>One reason coverage can be lower is if the ESSs are too small, which can be easily checked by looking at the minimum ESS for the log entry. If these values are much below 200 the chain length should be increased to be sure any low coverage is not due to insufficient convergence of the MCMC chain.</p>
<h2 id="low-coverage"><span class="header-section-number">4.2</span> Low coverage</h2>
<p>The occasional 91 is acceptable (the 95% HPD = 90 to 98 probability the implementation is correct) but coverage below 90 almost surely indicate an issue with the model or operator implementation. Also, coverage of 99 or 100 should be looked at with suspicion -- it may indicate overly wide uncertainty intervals.</p>
<p>If correct, distributed binomial with p=0.95, N=100:</p>
<table>
<thead>
<tr class="header">
<th align="right">k</th>
<th>p(x=k)</th>
<th>p(x&lt;=k)</th>
<th>p(x&gt;=k)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">90</td>
<td>0.0167</td>
<td>0.0282</td>
<td>0.9718</td>
</tr>
<tr class="even">
<td align="right">91</td>
<td>0.0349</td>
<td>0.0631</td>
<td>0.9369</td>
</tr>
<tr class="odd">
<td align="right">92</td>
<td>0.0649</td>
<td>0.1280</td>
<td>0.8720</td>
</tr>
<tr class="even">
<td align="right">93</td>
<td>0.1060</td>
<td>0.2340</td>
<td>0.7660</td>
</tr>
<tr class="odd">
<td align="right">94</td>
<td>0.1500</td>
<td>0.3840</td>
<td>0.6160</td>
</tr>
<tr class="even">
<td align="right">95</td>
<td>0.1800</td>
<td>0.5640</td>
<td>0.4360</td>
</tr>
<tr class="odd">
<td align="right">96</td>
<td>0.1781</td>
<td>0.7422</td>
<td>0.2578</td>
</tr>
<tr class="even">
<td align="right">97</td>
<td>0.1396</td>
<td>0.8817</td>
<td>0.1183</td>
</tr>
<tr class="odd">
<td align="right">98</td>
<td>0.0812</td>
<td>0.9629</td>
<td>0.0371</td>
</tr>
<tr class="even">
<td align="right">99</td>
<td>0.0312</td>
<td>0.9941</td>
<td>0.0059</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td>0.0059</td>
<td>1.0000</td>
<td>0.0000</td>
</tr>
</tbody>
</table>
<p>source <a href="https://www.di-mgt.com.au/binomial-calculator.html" class="uri">https://www.di-mgt.com.au/binomial-calculator.html</a> for different values of p and N.</p>
<h2 id="common-causes-of-low-coverage"><span class="header-section-number">4.3</span> Common causes of low coverage</h2>
<ul>
<li>trees cannot be reconstructed reliably (height should not be too small or large).</li>
<li>Hastings ratio in operators incorrectly implemented</li>
<li>bug in model likelihood</li>
</ul>
<h1 id="releasing"><span class="header-section-number">5</span> Releasing</h1>
<h2 id="setting-priors-in-beauti-template"><span class="header-section-number">5.1</span> Setting priors in BEAUti template</h2>
<ul>
<li>Priors should be made as uninformative as possible -- people will use defaults!</li>
<li>Make sure to consider a number of scenarios, e.g. for clock models, scenarios from <a href="http://www.beast2.org/2015/06/23/help-beast-acts-weird-or-how-to-set-up-rates.html">setting up rates</a> page on <a href="http://beast2.org">beast2.org</a>.</li>
</ul>
<h1 id="using-the-experimenter-package"><span class="header-section-number">6</span> Using the Experimenter package</h1>
<p>Experimenter is a <a href="http://beast2.org">BEAST 2</a> package that assists in simulation studies to verify correctness of the implementation. The goal of this particular simulation studies is to make sure that the model or operator implementation is correct by running N analysis on simulated data (using SequenceSimulator) on a tree and site model parameters sampled from a prior.</p>
<p>To run a simulation study:</p>
<ul>
<li>set up XML for desired model and sample from prior</li>
<li>generate (MCMC) analysis for each of the samples (say 100)</li>
<li>run the analyses</li>
<li>use loganalyser to summarise trace files</li>
<li>run CoverageCalculator to summarise coverage of parameters</li>
</ul>
<div class="figure">
<img src="figures/operatorTest.png" alt="Summary of files involved in testing an operator. Rectangles represent files, ovals represent programs." />
<p class="caption">Summary of files involved in testing an operator. Rectangles represent files, ovals represent programs.</p>
</div>
<p>Make sure to have the <a href="https://github.com/rbouckaert/Experimenter">Experimenter</a> package installed (details at the end).</p>
<h2 id="set-up-xml-for-desired-model-and-sample-from-prior"><span class="header-section-number">6.1</span> 1. Set up XML for desired model and sample from prior</h2>
<p>First, you set up a BEAST analysis in an XML file in the configuration that you want to test. Set the <code>sampleFromPrior=&quot;true&quot;</code> flag on the element with MCMC in it, and sample from the prior. Make sure that the number of samples in the trace log and tree log is the same and that they are sampled at a frequency such that there will be N useful samples (say N=100).</p>
<h2 id="generate-mcmc-analysis-for-each-of-the-samples"><span class="header-section-number">6.2</span> 2. Generate (MCMC) analysis for each of the samples</h2>
<p>You can use CoverageTestXMLGenerator to generate BEAST XML files from a template XML file. The XML file used to sample from the prior can be used for this (when setting the sampleFromPrior flag to false). You can run CoverageTestXMLGenerator using the BEAST applauncher utility (or via the <code>File/Launch Apps</code> meny in BEAUti).</p>
<p>CoverageTestXMLGenerator generates XML for performing coverage test (using CoverageCalculator) and has the following arguments:</p>
<p>-workingDir <filename> working directory where input files live and output directory is created -outDir <string> output directory where generated XML goes (as sub dir of working dir) (default: mcmc) -logFile trace log file containing model paramter values to use for generating sequence data -treeFile tree log file containing trees to generate sequence data on -xmlFile XML template file containing analysis to be merged with generated sequence data -skip <integer> numer of log file lines to skip (default: 1) -burnin <integer> percentage of trees to used as burn-in (and will be ignored) (default: 1) -useGamma [true|false] use gamma rate heterogeneity (default: true) -help show arguments</p>
<pre><code>NB: make sure to set sampleFromPrior=&quot;false&quot; in the XML.</code></pre>
<pre><code>NB: to ensure unique file name, add a parameter to logFileName, e.g.
logFileName=&quot;out$(N).log&quot;</code></pre>
<p>With this setting, when you run BEAST with <code>-D N=1</code> the log file will <code>be out1.log</code>.</p>
<h2 id="run-the-analyses"><span class="header-section-number">6.3</span> 3. Run the analyses</h2>
<p>Use your favourite method to run the N analyses, for example with a shell script</p>
<pre><code>for i in {0..99} do /path/to/beast/bin/beast -D N=$i beast$i.xml; done
</code></pre>
<p>where <code>/path/to/beast</code> the path to where BEAST is installed.</p>
<h2 id="use-loganalyser-to-summarise-trace-files"><span class="header-section-number">6.4</span> 4. Use loganalyser to summarise trace files</h2>
<p>Use the loganalyser utility that comes with BEAST in the bin directory. It is important to use the <code>-oneline</code> argument so that each log line gets summarised on a single line, which is what <code>CoverageCalculator</code> expects. Also, it is important that the log lines are in the same order as the log lines in the sample from the prior, so put the results for single digits before those of double digits, e.g. like so:</p>
<pre><code>/path/to/beast/bin/loganalyser -oneline out?.log out??.log &gt; results</code></pre>
<p>where <code>out</code> the base name of your output log file.</p>
<h2 id="run-coveragecalculator-to-summarise-coverage-of-parameters"><span class="header-section-number">6.5</span> 5. Run <code>CoverageCalculator</code> to summarise coverage of parameters</h2>
<p>You can run CoverageCalculator using the BEAST applauncher utility (or via the <code>File/Launch Apps</code> meny in BEAUti).</p>
<p>CoverageCalculator calculates how many times entries in log file are covered in an estimated 95% HPD interval and has the following arguments:</p>
<ul>
<li>log <filename> log file containing actual values</li>
<li>skip <integer> numer of log file lines to skip (default: 1)</li>
<li>logAnalyser <filename> file produced by loganalyser tool using the -oneline option, containing estimated values</li>
<li>out output file for trace log with truth and mean estimates. Not produced if not specified</li>
<li>help show arguments</li>
</ul>
<p>It produces a report like so:</p>
<pre><code>                                                coverage Mean ESS Min ESS
posterior                                       0      2188.41  1363.02
likelihood                                      0      4333.99  3042.15
prior                                           33     1613.20  891.92
treeLikelihood.dna                              0      4333.99  3042.15
TreeHeight                                      95     3076.44  2233.29
popSize                                         94     577.20  331.78
CoalescentConstant                              91     1620.76  787.30
logP(mrca(root))                                97     4320.70  3328.88
mrca.age(root)                                  95     3076.44  2233.29
clockRate                                       0      3046.64  2174.60
freqParameter.1                                 98     4332.76  3388.90
freqParameter.2                                 97     4337.93  3334.29
freqParameter.3                                 96     4378.30  3462.73
freqParameter.4                                 92     4348.83  3316.36</code></pre>
<p>Coverage should be around 95%. One reason coverage can be lower is if the ESSs are too small, which can be easily checked by looking at the <code>Mean ESS</code> and <code>Min ESS</code> columns. If these values are much below 200 the chain length should be increased to be sure any low coverage is not due to insufficient convergence of the MCMC chain. The occasional 90 or 91 is acceptable but coverage below 90 almost surely indicate an issue with the model or operator implementation.</p>
<p>The values for posterior, prior and treelikelihood can be ignored: it compares results from sampling from the prior with that of sampling from the posterior so they can be expected to be different.</p>
<h2 id="installing-experimenter-package"><span class="header-section-number">6.6</span> Installing Experimenter package</h2>
<p>Currently, you need to build from source (which depends on <a href="https://github.com/CompEvol/beast2">BEAST 2</a> and <a href="https://github.com/BEAST2-Dev/BEASTLabs/">BEASTlabs</a> code) and install by hand (see &quot;install by hand&quot; section in <a href="http://www.beast2.org/managing-packages/">managing packages</a>.</p>
<p>Quick guide</p>
<ul>
<li>clone <a href="https://github.com/CompEvol/beast2">BEAST 2</a>, <a href="https://github.com/BEAST2-Dev/BEASTLabs/">BEASTlabs</a> and <a href="https://github.com/rbouckaert/Experimenter/">Experimenter</a> all in same directory.</li>
<li>build BEAST 2 (using <code>ant Linux</code> in the beast2 folder), then BEASTLabs (using <code>ant addon</code> in the BEASTLabs folder), then Experimenter (again, using <code>ant addon</code> in the Experimenter folder) packages.</li>
<li>install BEASTlabs (using the <a href="www.beast2.org/managing-packages/#Server_machines">package manager</a>, or via BEAUti's <code>File/Manage pacakges</code> menu).</li>
<li>install Experimenter package by creating <code>Experimenter</code> folder in your <a href="http://www.beast2.org/managing-packages/#Installation_directories">BEAST package folder</a>, and unzip the file <code>Experimenter/build/dist/Experimenter.addon.v0.0.1.zip</code> (assuming version 0.0.1).</li>
</ul>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-bouckaert2019beast">
<p>Bouckaert R, Vaughan TG, Barido-Sottani J <em>et al.</em> BEAST 2.5: An advanced software platform for bayesian evolutionary analysis. <em>PLoS computational biology</em> 2019;<strong>15</strong>:e1006650.</p>
</div>
<div id="ref-beast">
<p>Bouckaert RR, Heled J, Kühnert D <em>et al.</em> BEAST 2: A software platform for Bayesian evolutionary analysis. <em>PLoS Comput Biol</em> 2014;<strong>10</strong>:e1003537.</p>
</div>
<div id="ref-bryant2012inferring">
<p>Bryant D, Bouckaert R, Felsenstein J <em>et al.</em> Inferring species trees directly from biallelic genetic markers: Bypassing gene trees in a full coalescent analysis. <em>Molecular biology and evolution</em> 2012;<strong>29</strong>:1917–32.</p>
</div>
<div id="ref-cuevas2015extremely">
<p>Cuevas JM, Geller R, Garijo R <em>et al.</em> Extremely high mutation rate of hiv-1 in vivo. <em>PLoS biology</em> 2015;<strong>13</strong>:e1002251.</p>
</div>
<div id="ref-beastbook">
<p>Drummond AJ, Bouckaert RR. <em>Bayesian Evolutionary Analysis with BEAST</em>. Cambridge: Cambridge University Press, 2015.</p>
</div>
<div id="ref-lynch2010evolution">
<p>Lynch M. Evolution of the mutation rate. <em>TRENDS in Genetics</em> 2010;<strong>26</strong>:345–52.</p>
</div>
<div id="ref-vaughan2013stochastic">
<p>Vaughan TG, Drummond AJ. A stochastic simulator of birth–death master equations with application to phylodynamics. <em>Molecular biology and evolution</em> 2013;<strong>30</strong>:1480–93.</p>
</div>
</div>
